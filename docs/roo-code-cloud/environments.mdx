---
description: Configure multi-port preview environments with automatic domain routing and environment variable injection for full-stack applications.
keywords:
  - Preview Environments
  - Multi-port
  - Named Ports
  - Environment Variables
  - Full Stack
  - Services
  - Postgres
  - Redis
  - Detached Commands
  - Tool Versions
  - mise
  - Initial Path
  - Subdomain Routing
---

# Preview Environments

Preview environments let you run multiple services in a cloud container with automatic domain routing. Each port you configure gets a unique public URL, and environment variables are injected so your applications can communicate with each other.

## Overview

When you spawn an environment, Roo Code Cloud:

1. Creates a cloud container with your configured ports exposed
2. Generates unique HTTPS domains for each port
3. Injects environment variables like `ROO_WEB_HOST` and `ROO_API_HOST` into your container
4. Clones your repositories, starts services, and runs your commands

This allows you to run a complete stack—frontend, API, workers—in a single preview environment where all the pieces can talk to each other.

## Configuration

Environments are configured in YAML format. Here's the complete schema:

```yaml
name: My Full Stack App
description: Frontend and API running together

repositories:
  - repository: myorg/frontend
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true

  - repository: myorg/backend
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true

ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001

services:
  - postgres16
  - redis7

env:
  NODE_ENV: development
```

## Named Ports

The `ports` section defines which ports to expose and what to call them:

```yaml
ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
  - name: ADMIN
    port: 3002
    initial_path: /dashboard
```

### Port Configuration Fields

| Field | Description | Required |
|-------|-------------|----------|
| `name` | Identifier for the port (used to generate environment variables) | Yes |
| `port` | The port number to expose | Yes |
| `initial_path` | Default path to append to the preview URL | No |
| `subdomain` | Subdomain to set on the `Host` header when forwarding requests to the app | No |

For each named port, an environment variable is injected into your container:

| Port Config | Environment Variable | Example Value |
|-------------|---------------------|---------------|
| `name: WEB, port: 3000` | `ROO_WEB_HOST` | `https://abc123.preview.roocode.cloud` |
| `name: API, port: 3001` | `ROO_API_HOST` | `https://def456.preview.roocode.cloud` |
| `name: ADMIN, port: 3002` | `ROO_ADMIN_HOST` | `https://ghi789.preview.roocode.cloud` |

### Naming Rules

Port names must:
- Start with a letter
- Contain only letters, numbers, and underscores
- Be 1-50 characters long

The name is converted to uppercase for the environment variable (e.g., `web` becomes `ROO_WEB_HOST`).

### Limits

You can configure up to **4 named ports** per environment.

### Initial Path

Use `initial_path` to specify the default URL path for a port's preview link. This is useful when your application's entry point isn't at the root path.

For example, if your app requires authentication and the login page is at `/login`:

```yaml
ports:
  - name: WEB
    port: 3000
    initial_path: /login
```

When the environment starts, the preview URL provided in the UI and task will be `https://abc123.preview.roocode.cloud/login` instead of the root URL.

:::note
The `ROO_<NAME>_HOST` environment variable always contains the base URL without the initial path (e.g., `https://abc123.preview.roocode.cloud`). The `initial_path` only affects the preview link shown in the UI.
:::

#### Validation Rules

The `initial_path` must:
- Start with a forward slash (`/`)
- Contain only valid URI characters

Query parameters and hash fragments are allowed. Valid examples:
- `/login`
- `/dashboard`
- `/api/v1/health`
- `/app/projects/123`
- `/login?redirect=home`
- `/docs#getting-started`

Invalid examples:
- `login` (missing leading slash)

### Subdomain Routing

Use the `subdomain` field to enable subdomain-based routing for frameworks that rely on the `Host` header to distinguish tenants or admin panels (e.g., Rails, Django, Phoenix).

When a port has a `subdomain` configured, the proxy rewrites the `Host` and `X-Forwarded-Host` headers to `{subdomain}.localhost:{port}` before forwarding the request to your application. The browser URL stays unchanged -- the rewriting happens internally inside the sandbox.

```yaml
ports:
  - name: WEB
    port: 3000
    subdomain: admin
```

With this configuration, your application receives requests with `Host: admin.localhost:3000`, allowing it to route based on the subdomain without any DNS or infrastructure changes. WebSocket connections also receive the rewritten `Host` header.

#### Validation Rules

The `subdomain` value must be a valid DNS hostname:
- Lowercase alphanumeric characters, hyphens, and dots only
- Must start and end with an alphanumeric character
- 1-253 characters long

Valid examples:
- `admin`
- `tenant1`
- `us-west.api`

Invalid examples:
- `Admin` (uppercase not allowed)
- `-admin` (cannot start with a hyphen)
- `admin-` (cannot end with a hyphen)

#### Use Cases

- **Multi-tenant apps**: Route `tenant1.localhost:3000` and `tenant2.localhost:3000` to different tenants in a single application
- **Admin panels**: Serve an admin interface on `admin.localhost:3000` while the main app runs on the root domain
- **Subdomain APIs**: Frameworks like Rails can use `api.localhost:3000` to route API requests to a separate controller namespace

## Using Environment Variables in Your Code

Use the `ROO_<NAME>_HOST` variables instead of hardcoded URLs so your services can find each other in both preview and local environments:

```typescript
// Backend: configure CORS with the injected frontend URL
app.use(cors({
  origin: process.env.ROO_WEB_HOST || 'http://localhost:3000'
}));

// Frontend (Vite): pass the API URL at build time
// vite.config.ts
export default defineConfig({
  define: {
    'import.meta.env.API_URL': JSON.stringify(process.env.ROO_API_HOST || 'http://localhost:3001')
  }
})
```

For static site frameworks (Vite, Next.js, CRA), the API URL needs to be set at build time via command-level `env`:

```yaml
commands:
  - name: Build
    run: npm run build
    env:
      VITE_API_URL: ${ROO_API_HOST}
```

## Repositories

List the repositories to clone into your environment:

```yaml
repositories:
  - repository: myorg/frontend
    commands:
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build
      - name: Start dev server
        run: npm run dev
        detached: true
        logfile: /tmp/frontend.log

  - repository: myorg/backend
    commands:
      - name: Install dependencies
        run: npm install
      - name: Run migrations
        run: npm run db:migrate
      - name: Start server
        run: npm run start
        detached: true
        logfile: /tmp/backend.log
```

### Repository Format

Use the `owner/repo` format (e.g., `myorg/my-app`).

### Commands

Each repository can have its own commands that run in order. Commands support:

| Field | Description | Default |
|-------|-------------|---------|
| `name` | Display name for the command | Required |
| `run` | The shell command to execute | Required |
| `working_dir` | Relative directory to run the command in | Repository root |
| `cwd` | Absolute path to run the command in | Repository root |
| `env` | Command-specific environment variables | None |
| `timeout` | Maximum seconds to wait | 600 |
| `continue_on_error` | Keep going if command fails | false |
| `detached` | Run in the background (see below) | false |
| `logfile` | File path to write stdout/stderr when `detached` is true | None |

### Background Processes

To start a long-running process like a dev server, use `detached: true`. This runs the command in the background so subsequent commands can execute immediately:

```yaml
commands:
  - name: Install
    run: npm install
  - name: Start dev server
    run: npm run dev
    detached: true
    logfile: /tmp/dev-server.log
```

When `detached` is true, the command runs via `nohup` and the worker moves on after confirming the process started. If `logfile` is set, stdout and stderr are written to that path — useful for debugging startup issues.

### Automatic Tool Installation

If a repository contains a `.tool-versions` file (used by [mise](https://mise.jdx.dev/) / asdf), Roo Code Cloud automatically runs `mise install` after cloning. This installs the correct versions of tools like Node.js, Python, Ruby, Go, or any other runtime your project requires — before any of your setup commands execute.

```
# .tool-versions
nodejs 20.11.0
python 3.12.1
```

## Services

Add managed database and cache services:

```yaml
services:
  - redis7
  - postgres16
```

### Available Services

| Service | Default Port | Connection Variables |
|---------|--------------|---------------------|
| `redis6` | 6379 | `REDIS_URL` |
| `redis7` | 6379 | `REDIS_URL` |
| `postgres15` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `postgres16` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `postgres17` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `mysql8` | 3306 | `DATABASE_URL`, `MYSQL_*` |
| `mariadb10` | 3306 | `DATABASE_URL`, `MARIADB_*` |
| `clickhouse` | 9000 | `CLICKHOUSE_URL` |

### Custom Ports

If you need a service on a non-default port:

```yaml
services:
  - name: postgres16
    port: 5433
```

## Environment Variables

Define environment variables available to all commands:

```yaml
env:
  NODE_ENV: development
  LOG_LEVEL: debug
  FEATURE_FLAGS: "new-ui,beta-api"
```

These are merged with:
1. Service connection variables (e.g., `DATABASE_URL`)
2. Named port variables (e.g., `ROO_WEB_HOST`)
3. Command-specific variables (highest priority)

## Complete Example

Here's a full-stack application with a React frontend, Hono API, and background worker:

```yaml
name: E-Commerce Platform
description: Full stack with frontend, API, and worker

repositories:
  - repository: acme/storefront
    commands:
      - name: Install
        run: npm install
      - name: Build
        run: npm run build
        env:
          VITE_API_URL: ${ROO_API_HOST}
      - name: Serve
        run: npx serve -s dist -l 3000
        detached: true
        logfile: /tmp/storefront.log

  - repository: acme/api
    commands:
      - name: Install
        run: npm install
      - name: Migrate
        run: npm run db:push
      - name: Start
        run: npm run start
        detached: true
        logfile: /tmp/api.log
        env:
          ALLOWED_ORIGINS: ${ROO_WEB_HOST}

  - repository: acme/worker
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run start
        detached: true
        logfile: /tmp/worker.log

ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
  - name: WORKER
    port: 3002

services:
  - postgres16
  - redis7

env:
  NODE_ENV: production
  LOG_LEVEL: info
```

After the environment starts, you'll get unique URLs for each port. Visit the WEB URL to access your running application.

## Common Issues

### CORS Errors

In a preview environment, your frontend and backend run on different domains (e.g., `https://abc123.preview.roocode.cloud` and `https://def456.preview.roocode.cloud`). Browsers block cross-origin requests by default, so you need to configure both sides: the backend must allow the frontend's origin, and the frontend dev server must accept the preview domain.

Make sure both ports are defined so the `ROO_*_HOST` variables get injected:

```yaml
ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
```

#### Backend: Allow the frontend origin

Use `ROO_WEB_HOST` to configure your backend's CORS policy:

```typescript
// Express
import cors from 'cors';
app.use(cors({ origin: process.env.ROO_WEB_HOST || 'http://localhost:3000' }));

// Hono
import { cors } from 'hono/cors';
app.use(cors({ origin: process.env.ROO_WEB_HOST || 'http://localhost:3000' }));

// Fastify
app.register(import('@fastify/cors'), {
  origin: process.env.ROO_WEB_HOST || 'http://localhost:3000'
});
```

#### Frontend: Allow the preview domain

Dev servers like Vite and Next.js reject requests from unrecognized hosts by default. You need to allow the preview domain so the dev server responds to requests on `https://<id>.preview.roocode.cloud`:

```typescript
// Vite — vite.config.ts
export default defineConfig({
  server: {
    allowedHosts: process.env.ROO_WEB_HOST
      ? [new URL(process.env.ROO_WEB_HOST).hostname]
      : [],
  }
})

// Next.js — next.config.ts
export default {
  allowedDevOrigins: process.env.ROO_WEB_HOST
    ? [process.env.ROO_WEB_HOST]
    : [],
}
```

### Managing Frontend API URLs with `.env` Files

Frontends typically need the API URL at build time. If your project already uses `.env` files (via dotenv, dotenvx, or framework built-ins like Vite's `.env.local`), you can write the injected `ROO_API_HOST` into a `.env` file as a setup command — no code changes needed:

```yaml
repositories:
  - repository: myorg/frontend
    commands:
      - name: Configure API URL
        run: echo "VITE_API_URL=${ROO_API_HOST}" >> .env.local
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true
```

This works with any framework that reads `.env` files:

| Framework | File | Variable prefix |
|-----------|------|-----------------|
| Vite | `.env.local` | `VITE_` |
| Next.js | `.env.local` | `NEXT_PUBLIC_` |
| Create React App | `.env.local` | `REACT_APP_` |

This approach keeps your environment config simple and avoids modifying application code.

## Tips

- **Use `ROO_*_HOST` variables, not hardcoded URLs.** Always fall back to localhost for local dev: `process.env.ROO_API_HOST || 'http://localhost:3001'`.
- **Use consistent uppercase port names.** `WEB`, `API`, `ADMIN` — not `frontend`, `BACKEND_API`, `Admin_Panel`.
