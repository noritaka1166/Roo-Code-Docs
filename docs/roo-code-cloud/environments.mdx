---
description: Configure multi-port preview environments with automatic domain routing and environment variable injection for full-stack applications.
keywords:
  - Preview Environments
  - Multi-port
  - Named Ports
  - Environment Variables
  - Full Stack
  - Services
  - Postgres
  - Redis
  - Detached Commands
  - Tool Versions
  - mise
  - Initial Path
  - Subdomain Routing
  - Proxied Ports
  - Direct Port Access
---

# Preview Environments

Preview environments let you run multiple services in a cloud container with automatic domain routing. Each port you configure gets a unique public URL, and environment variables are injected so your applications can communicate with each other.

## Overview

When you spawn an environment, Roo Code Cloud:

1. Creates a cloud container with your configured ports exposed
2. Generates unique HTTPS domains for each port
3. Injects environment variables like `ROO_WEB_HOST` and `ROO_API_HOST` into your container
4. Clones your repositories, starts services, and runs your commands

This allows you to run a complete stack—frontend, API, workers—in a single preview environment where all the pieces can talk to each other.

## Configuration

Environments are configured in YAML format. Here's the complete schema:

```yaml
name: My Full Stack App
description: Frontend and API running together

repositories:
  - repository: myorg/frontend
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true

  - repository: myorg/backend
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true

ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001

services:
  - postgres16
  - redis7

env:
  NODE_ENV: development
```

## Named Ports

The `ports` section defines which ports to expose and what to call them:

```yaml
ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
  - name: ADMIN
    port: 3002
    initial_path: /dashboard
```

### Port Configuration Fields

| Field | Description | Required |
|-------|-------------|----------|
| `name` | Identifier for the port (used to generate environment variables) | Yes |
| `port` | The port number to expose | Yes |
| `unauthenticated` | Skip authentication for this port's preview URL (`false` by default). See [Public Ports](#public-ports-unauthenticated) | No |
| `proxied` | Whether traffic goes through the auth proxy (`true` by default). Set to `false` for direct port access (see [Direct Port Access](#direct-port-access-non-proxied)) | No |
| `initial_path` | Default path to append to the preview URL | No |
| `subdomain` | Subdomain to set on the `Host` header when forwarding requests to the app | No |

For each named port, an environment variable is injected into your container:

| Port Config | Environment Variable | Example Value |
|-------------|---------------------|---------------|
| `name: WEB, port: 3000` | `ROO_WEB_HOST` | `https://abc123.preview.roocode.cloud` |
| `name: API, port: 3001` | `ROO_API_HOST` | `https://def456.preview.roocode.cloud` |
| `name: ADMIN, port: 3002` | `ROO_ADMIN_HOST` | `https://ghi789.preview.roocode.cloud` |

### Naming Rules

Port names must:
- Start with a letter
- Contain only letters, numbers, and underscores
- Be 1-50 characters long

The name is converted to uppercase for the environment variable (e.g., `web` becomes `ROO_WEB_HOST`).

### Limits

Port limits depend on whether ports are proxied (default) or non-proxied:

- **Proxied ports** (default): up to **10** per environment. These share a single internal port slot via multiplexing.
- **Non-proxied ports** (`proxied: false`): up to **1** per environment. Each non-proxied port consumes a dedicated port slot.

### Initial Path

Use `initial_path` to specify the default URL path for a port's preview link. This is useful when your application's entry point isn't at the root path.

For example, if your app requires authentication and the login page is at `/login`:

```yaml
ports:
  - name: WEB
    port: 3000
    initial_path: /login
```

When the environment starts, the preview URL provided in the UI and task will be `https://abc123.preview.roocode.cloud/login` instead of the root URL.

:::note
The `ROO_<NAME>_HOST` environment variable always contains the base URL without the initial path (e.g., `https://abc123.preview.roocode.cloud`). The `initial_path` only affects the preview link shown in the UI.
:::

#### Validation Rules

The `initial_path` must:
- Start with a forward slash (`/`)
- Contain only valid URI characters

Query parameters and hash fragments are allowed. Valid examples:
- `/login`
- `/dashboard`
- `/api/v1/health`
- `/app/projects/123`
- `/login?redirect=home`
- `/docs#getting-started`

Invalid examples:
- `login` (missing leading slash)

### Subdomain Routing

Use the `subdomain` field to enable subdomain-based routing for frameworks that rely on the `Host` header to distinguish tenants or admin panels (e.g., Rails, Django, Phoenix).

When a port has a `subdomain` configured, the proxy rewrites the `Host` and `X-Forwarded-Host` headers to `{subdomain}.localhost:{port}` before forwarding the request to your application. The browser URL stays unchanged -- the rewriting happens internally inside the sandbox.

```yaml
ports:
  - name: WEB
    port: 3000
    subdomain: admin
```

With this configuration, your application receives requests with `Host: admin.localhost:3000`, allowing it to route based on the subdomain without any DNS or infrastructure changes. WebSocket connections also receive the rewritten `Host` header.

#### Validation Rules

The `subdomain` value must be a valid DNS hostname:
- Lowercase alphanumeric characters, hyphens, and dots only
- Must start and end with an alphanumeric character
- 1-253 characters long

Valid examples:
- `admin`
- `tenant1`
- `us-west.api`

Invalid examples:
- `Admin` (uppercase not allowed)
- `-admin` (cannot start with a hyphen)
- `admin-` (cannot end with a hyphen)

#### Use Cases

- **Multi-tenant apps**: Route `tenant1.localhost:3000` and `tenant2.localhost:3000` to different tenants in a single application
- **Admin panels**: Serve an admin interface on `admin.localhost:3000` while the main app runs on the root domain
- **Subdomain APIs**: Frameworks like Rails can use `api.localhost:3000` to route API requests to a separate controller namespace

### Public Ports (Unauthenticated)

By default, all preview URLs require authentication -- visitors must be signed in to your Roo Code Cloud organization to access them. Setting `unauthenticated: true` on a port disables this auth check while keeping the proxy layer intact.

```yaml
ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
    unauthenticated: true
  - name: WEBHOOK
    port: 3002
    unauthenticated: true
```

Use `unauthenticated: true` when you need:

- **API endpoints** that your frontend or external clients call directly (the auth proxy would otherwise block non-browser requests)
- **Webhook receivers** that need to accept requests from external services (e.g., Stripe, GitHub)
- **Public-facing endpoints** like documentation sites or landing pages
- **Health checks** or status pages accessed by monitoring tools

The port still goes through the proxy, so it benefits from HTTPS termination and domain routing. Only the authentication requirement is removed.

### Direct Port Access (Non-Proxied)

By default, all ports are proxied through an authentication layer that validates requests before forwarding them to your application. Setting `proxied: false` bypasses this proxy entirely and exposes the port directly on the sandbox domain.

:::tip[Try `unauthenticated: true` first]
If you just need to skip authentication (e.g., for a public-facing endpoint or webhook), use `unauthenticated: true` instead. It keeps the proxy in place while disabling the auth check, and doesn't count against the stricter non-proxied port limit. Only reach for `proxied: false` when the proxy itself is the problem.
:::

```yaml
ports:
  - name: WEB
    port: 3000
  - name: METRICS
    port: 9090
    proxied: false
```

Use `proxied: false` only when the proxy layer itself is incompatible with your use case:

- **WebSocket or streaming connections** that are disrupted by the proxy intermediary
- **Services with custom connection handling** that conflict with the proxy's request processing

:::warning[Warning]
When `proxied` is `false`, the port is **completely exposed without authentication**, regardless of the `unauthenticated` setting. Non-proxied ports also count against a stricter limit (1 per environment vs. 10 for proxied ports). Only use this as a last resort when other options don't work.
:::

The `ROO_<NAME>_HOST` environment variable for a non-proxied port points to the direct sandbox domain instead of the preview proxy URL. Your application code doesn't need to change -- just use the injected variable as usual:

```typescript
// Works the same whether the port is proxied or not
const metricsUrl = process.env.ROO_METRICS_HOST || 'http://localhost:9090';
```

## Using Environment Variables in Your Code

Use the `ROO_<NAME>_HOST` variables instead of hardcoded URLs so your services can find each other in both preview and local environments:

```typescript
// Backend: configure CORS with the injected frontend URL
app.use(cors({
  origin: process.env.ROO_WEB_HOST || 'http://localhost:3000'
}));

// Frontend (Vite): pass the API URL at build time
// vite.config.ts
export default defineConfig({
  define: {
    'import.meta.env.API_URL': JSON.stringify(process.env.ROO_API_HOST || 'http://localhost:3001')
  }
})
```

For static site frameworks (Vite, Next.js, CRA), the API URL needs to be set at build time via command-level `env`:

```yaml
commands:
  - name: Build
    run: npm run build
    env:
      VITE_API_URL: ${ROO_API_HOST}
```

## Repositories

List the repositories to clone into your environment:

```yaml
repositories:
  - repository: myorg/frontend
    commands:
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build
      - name: Start dev server
        run: npm run dev
        detached: true
        logfile: /tmp/frontend.log

  - repository: myorg/backend
    commands:
      - name: Install dependencies
        run: npm install
      - name: Run migrations
        run: npm run db:migrate
      - name: Start server
        run: npm run start
        detached: true
        logfile: /tmp/backend.log
```

### Repository Configuration Fields

| Field | Description | Required |
|-------|-------------|----------|
| `repository` | Repository in `owner/repo` format (e.g., `myorg/my-app`) | Yes |
| `branch` | Branch to checkout (defaults to the repository's default branch) | No |
| `tool_versions` | Tool versions to install via [mise](https://mise.jdx.dev/) (see [Tool Installation](#automatic-tool-installation)) | No |
| `commands` | Ordered list of commands to run after cloning | No |

### Commands

Each repository can have its own commands that run in order. Commands support:

| Field | Description | Default |
|-------|-------------|---------|
| `name` | Display name for the command | Required |
| `run` | The shell command to execute | Required |
| `working_dir` | Relative directory to run the command in | Repository root |
| `cwd` | Absolute path to run the command in | Repository root |
| `env` | Command-specific environment variables | None |
| `timeout` | Maximum seconds to wait | 600 |
| `continue_on_error` | Keep going if command fails | false |
| `detached` | Run in the background (see below) | false |
| `logfile` | File path to write stdout/stderr when `detached` is true | None |

### Background Processes

To start a long-running process like a dev server, use `detached: true`. This runs the command in the background so subsequent commands can execute immediately:

```yaml
commands:
  - name: Install
    run: npm install
  - name: Start dev server
    run: npm run dev
    detached: true
    logfile: /tmp/dev-server.log
```

When `detached` is true, the command runs via `nohup` and the worker moves on after confirming the process started. If `logfile` is set, stdout and stderr are written to that path — useful for debugging startup issues.

### Automatic Tool Installation

Roo Code Cloud uses [mise](https://mise.jdx.dev/) to manage tool versions. There are two ways to specify which versions of Node.js, Python, Ruby, Go, or other runtimes your project needs.

#### Option 1: `tool_versions` in the environment config

Set `tool_versions` directly on a repository entry to declare tool versions without modifying the repo itself. Roo Code Cloud generates a `.tool-versions` file from this config and adds it to `.git/info/exclude` so it stays out of version control.

```yaml
repositories:
  - repository: myorg/backend
    tool_versions:
      node: "20.11.0"
      python: "3.12.1"
    commands:
      - name: Install
        run: npm install
```

This takes priority over any existing `.tool-versions` file in the repository.

#### Option 2: `.tool-versions` file in the repository

If a repository already contains a `.tool-versions` file (used by mise / asdf), Roo Code Cloud automatically picks it up and runs `mise install` after cloning — no extra configuration needed.

```
# .tool-versions
node 20.11.0
python 3.12.1
```

:::tip
Use `tool_versions` in the environment config when you want to pin versions per-environment without committing changes to the repository. Use a `.tool-versions` file in the repo when all environments should share the same versions.
:::

## Services

Add managed database and cache services:

```yaml
services:
  - redis7
  - postgres16
```

### Available Services

| Service | Default Port | Connection Variables |
|---------|--------------|---------------------|
| `redis6` | 6379 | `REDIS_URL` |
| `redis7` | 6379 | `REDIS_URL` |
| `postgres15` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `postgres16` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `postgres17` | 5432 | `DATABASE_URL`, `POSTGRES_*` |
| `mysql8` | 3306 | `DATABASE_URL`, `MYSQL_*` |
| `mariadb10` | 3306 | `DATABASE_URL`, `MARIADB_*` |
| `clickhouse` | 9000 | `CLICKHOUSE_URL` |

### Custom Ports

If you need a service on a non-default port:

```yaml
services:
  - name: postgres16
    port: 5433
```

## Environment Variables

Define environment variables available to all commands:

```yaml
env:
  NODE_ENV: development
  LOG_LEVEL: debug
  FEATURE_FLAGS: "new-ui,beta-api"
```

These are merged with:
1. Service connection variables (e.g., `DATABASE_URL`)
2. Named port variables (e.g., `ROO_WEB_HOST`)
3. Command-specific variables (highest priority)

## Complete Example

Here's a full-stack application with a React frontend, Hono API, and background worker:

```yaml
name: E-Commerce Platform
description: Full stack with frontend, API, and worker

repositories:
  - repository: acme/storefront
    commands:
      - name: Install
        run: npm install
      - name: Build
        run: npm run build
        env:
          VITE_API_URL: ${ROO_API_HOST}
      - name: Serve
        run: npx serve -s dist -l 3000
        detached: true
        logfile: /tmp/storefront.log

  - repository: acme/api
    tool_versions:
      node: "20.11.0"
    commands:
      - name: Install
        run: npm install
      - name: Migrate
        run: npm run db:push
      - name: Start
        run: npm run start
        detached: true
        logfile: /tmp/api.log
        env:
          ALLOWED_ORIGINS: ${ROO_WEB_HOST}

  - repository: acme/worker
    branch: main
    commands:
      - name: Install
        run: npm install
      - name: Start
        run: npm run start
        detached: true
        logfile: /tmp/worker.log

ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
  - name: WORKER
    port: 3002

services:
  - postgres16
  - redis7

env:
  NODE_ENV: production
  LOG_LEVEL: info
```

After the environment starts, you'll get unique URLs for each port. Visit the WEB URL to access your running application.

## Common Issues

### CORS Errors

In a preview environment, your frontend and backend run on different domains (e.g., `https://abc123.preview.roocode.cloud` and `https://def456.preview.roocode.cloud`). Browsers block cross-origin requests by default, so you need to configure both sides: the backend must allow the frontend's origin, and the frontend dev server must accept the preview domain.

Make sure both ports are defined so the `ROO_*_HOST` variables get injected:

```yaml
ports:
  - name: WEB
    port: 3000
  - name: API
    port: 3001
```

#### Backend: Allow the frontend origin

Use `ROO_WEB_HOST` to configure your backend's CORS policy:

```typescript
// Express
import cors from 'cors';
app.use(cors({ origin: process.env.ROO_WEB_HOST || 'http://localhost:3000' }));

// Hono
import { cors } from 'hono/cors';
app.use(cors({ origin: process.env.ROO_WEB_HOST || 'http://localhost:3000' }));

// Fastify
app.register(import('@fastify/cors'), {
  origin: process.env.ROO_WEB_HOST || 'http://localhost:3000'
});
```

#### Frontend: Allow the preview domain

Dev servers like Vite and Next.js reject requests from unrecognized hosts by default. You need to allow the preview domain so the dev server responds to requests on `https://<id>.preview.roocode.cloud`:

```typescript
// Vite — vite.config.ts
export default defineConfig({
  server: {
    allowedHosts: process.env.ROO_WEB_HOST
      ? [new URL(process.env.ROO_WEB_HOST).hostname]
      : [],
  }
})

// Next.js — next.config.ts
export default {
  allowedDevOrigins: process.env.ROO_WEB_HOST
    ? [process.env.ROO_WEB_HOST]
    : [],
}
```

### Managing Frontend API URLs with `.env` Files

Frontends typically need the API URL at build time. If your project already uses `.env` files (via dotenv, dotenvx, or framework built-ins like Vite's `.env.local`), you can write the injected `ROO_API_HOST` into a `.env` file as a setup command — no code changes needed:

```yaml
repositories:
  - repository: myorg/frontend
    commands:
      - name: Configure API URL
        run: echo "VITE_API_URL=${ROO_API_HOST}" >> .env.local
      - name: Install
        run: npm install
      - name: Start
        run: npm run dev
        detached: true
```

This works with any framework that reads `.env` files:

| Framework | File | Variable prefix |
|-----------|------|-----------------|
| Vite | `.env.local` | `VITE_` |
| Next.js | `.env.local` | `NEXT_PUBLIC_` |
| Create React App | `.env.local` | `REACT_APP_` |

This approach keeps your environment config simple and avoids modifying application code.

## Tips

- **Use `ROO_*_HOST` variables, not hardcoded URLs.** Always fall back to localhost for local dev: `process.env.ROO_API_HOST || 'http://localhost:3001'`.
- **Use consistent uppercase port names.** `WEB`, `API`, `ADMIN` — not `frontend`, `BACKEND_API`, `Admin_Panel`.
