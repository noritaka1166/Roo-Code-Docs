---
description: Apply unified diff patches to multiple files in a single operation using the apply_patch tool in Roo Code.
keywords:
  - apply_patch
  - patch
  - unified diff
  - multi-file edits
  - file operations
  - Roo Code tools
  - diff patches
---

# apply_patch

The `apply_patch` tool applies unified diff patches to multiple files in a single operation. It supports custom patch headers for adding, deleting, and updating files, making it ideal for complex multi-file refactoring operations.

---

## Parameters

The tool accepts these parameters:

- `patch` (required): A unified diff patch string with custom headers. Supports `*** Add File:`, `*** Delete File:`, and `*** Update File:` headers.

---

## What It Does

This tool processes unified diff patches containing operations for multiple files. It parses the patch content, identifies file operations (add, delete, update), and applies the changes atomically. Unlike [`apply_diff`](/advanced-usage/available-tools/apply-diff) which handles single-file search-and-replace operations, `apply_patch` works with traditional unified diff format.

---

## When is it used?

- When applying patches generated by version control systems or diff tools
- When performing complex multi-file refactoring with precise line-level changes
- When migrating code changes from one branch or repository to another
- When bulk-adding, updating, or removing multiple files in one operation
- When working with patches from external sources or automated tools

---

## Key Features

- Supports multiple files in a single patch operation
- Handles file addition, deletion, and modification
- Uses unified diff format for precise line-level control
- Custom headers (`*** Add File:`, `*** Delete File:`, `*** Update File:`) for clarity
- Atomic operations with validation before applying changes
- Compatible with standard diff/patch tooling output

---

## Limitations

- Requires proper unified diff format syntax
- Line numbers and context must match existing file content
- Cannot apply patches with conflicts or mismatched context
- Less flexible than search-and-replace tools for fuzzy matching
- Requires exact line-level accuracy in patches

---

## How It Works

When the `apply_patch` tool is invoked, it follows this process:

1. **Patch Parsing**: Parses the patch string to identify custom headers (`*** Add File:`, `*** Delete File:`, `*** Update File:`) and unified diff blocks.
2. **Operation Identification**: Groups changes by file path and operation type (add, delete, update).
3. **Validation**: Validates that target files exist (for updates/deletes) or can be created (for adds).
4. **RooIgnore Check**: Ensures target files are not restricted by `.rooignore` rules.
5. **User Review**: Presents the patch operations for user review and approval.
6. **Application**: Applies approved changes to each file sequentially.
7. **Feedback**: Reports success or failure for each file operation.

---

## Patch Format

The patch format uses custom headers followed by unified diff blocks:

```diff
*** Add File: src/utils/newHelper.ts
--- /dev/null
+++ b/src/utils/newHelper.ts
@@ -0,0 +1,5 @@
+export function helperFunction(value: string): string {
+  return value.toUpperCase();
+}

*** Update File: src/main.ts
--- a/src/main.ts
+++ b/src/main.ts
@@ -10,7 +10,7 @@
 import { config } from './config';
-const timeout = 5000;
+const timeout = 10000;
 
 function main() {

*** Delete File: src/deprecated/oldUtil.ts
```

---

## Relation to Other Tools

- [`apply_diff`](/advanced-usage/available-tools/apply-diff): Use for single-file search-and-replace with fuzzy matching
- `apply_patch`: Use for multi-file operations with unified diff format
- [`write_to_file`](/advanced-usage/available-tools/write-to-file): Use for creating entire new files
