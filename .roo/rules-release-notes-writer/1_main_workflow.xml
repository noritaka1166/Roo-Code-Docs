<workflow_instructions>
  <mode_overview>
    Automates creating release notes for new Roo Code versions. Fetches pull requests
    from GitHub, analyzes changes, generates user-focused notes, and handles Discord and Reddit
    formatting. Supports bare version requests (runs full workflow) and auto-detection of missing versions.
  </mode_overview>

  <entry_patterns>
    <pattern type="create_new">
      <trigger>Create release notes for X.Y.Z</trigger>
      <action>Full release notes workflow</action>
    </pattern>
    <pattern type="discord_only">
      <trigger>Discord release notes for X.Y.Z</trigger>
      <action>Generate Discord format from existing files</action>
    </pattern>
    <pattern type="discord_combined">
      <trigger>Combined Discord announcement for X.Y.Z, X.Y.Z, and X.Y.Z</trigger>
      <action>Generate combined Discord format from multiple release files</action>
    </pattern>
    <pattern type="version_only">
      <trigger>^v?[\d.]+$</trigger>
      <action>Full release notes workflow (PR-by-PR analysis, changelog alignment, inclusion policy)</action>
    </pattern>
    <pattern type="latest">
      <trigger>latest</trigger>
      <action>Auto-detect missing versions from changelog</action>
    </pattern>
    <pattern type="reddit_only">
      <trigger>Reddit release notes for X.Y.Z</trigger>
      <action>Generate Reddit format from existing files</action>
    </pattern>
  </entry_patterns>

  <critical_date_format>
    <format>ISO 8601: YYYY-MM-DD</format>
    <specification>
      - YYYY = 4-digit year (e.g., 2025)
      - MM = 2-digit MONTH (01-12) - NOT the day!
      - DD = 2-digit day (01-31)
    </specification>
    <examples>
      <correct>2025-07-18 (July 18, 2025)</correct>
      <correct>2025-01-13 (January 13, 2025)</correct>
      <incorrect>2025-18-07 (Invalid - would mean 18th month)</incorrect>
    </examples>
    <implementation>
      When PR list provided directly: Use new Date().toISOString().split('T')[0] (UTC)
      Note: toISOString returns UTC; do not convert to local time to avoid off-by-one day differences.
    </implementation>
  </critical_date_format>

  <main_workflow>
    <phase name="initialization">
      <step number="1">
        <action>Analyze request type and route to appropriate workflow</action>
        <decision_tree>
          <if condition="latest">Execute latest_version_detection</if>
          <if condition="discord_only">Execute discord_workflow</if>
          <if condition="version_only">Continue with standard workflow</if>
          <else>Continue with standard workflow</else>
        </decision_tree>
      </step>
      
      <step number="2">
        <action>Initialize tracking</action>
        <tool>update_todo_list</tool>
        <todos>
          - Determine version range
          - Fetch PRs (if needed)
          - Process and analyze PRs
          - Create documentation files
          - Update indexes and sidebars
          - Handle user review
        </todos>
      </step>
    </phase>

    <phase name="data_collection">
      <step number="1">
        <action>Determine version range</action>
        <tool>list_files in docs/update-notes</tool>
      </step>
      
      <step number="2" optional="true">
        <action>Handle user-provided PR list</action>
        <when>User provides PR numbers directly</when>
        <critical>Validate date format (MM is month, not day)</critical>
      </step>
      
      <step number="3">
        <action>Fetch PRs from GitHub using simplified approach</action>
        <skip_if>User provided PR list</skip_if>
        <command><![CDATA[
# Replace X.Y.Z with the actual version number
TAG_INPUT="X.Y.Z"; TAG="v$(echo "$TAG_INPUT" | sed 's/^v//')"; \
END=$(gh release view "$TAG" --repo RooCodeInc/Roo-Code --json publishedAt --jq '.publishedAt'); \
START=$(gh release list --repo RooCodeInc/Roo-Code --limit 1000 --json tagName,publishedAt --jq '[.[]|{tag:.tagName,at:.publishedAt}]|sort_by(.at)|(map(.tag)|index("'"$TAG"'")) as $i | .[($i-1)].at'); \
gh pr list --repo RooCodeInc/Roo-Code --state merged --base main --limit 1000 \
  --json number,title,author,url,mergedAt \
  --jq 'map(select(.mergedAt >= "'"$START"'" and .mergedAt <= "'"$END"'")) | sort_by(.mergedAt)[] | [.number,.mergedAt,.author.login,.title,.url] | @tsv'
        ]]></command>
        <output_description>
          Returns JSON array of PR objects sorted by merge date, including all metadata needed for PR processing
        </output_description>
      </step>
    </phase>

    <phase name="pr_processing">
      <overview>
        Process each PR inline to gather details, categorize changes, and identify documentation needs.
        All analysis happens within this task without spawning subtasks.
      </overview>
      
      <initialization>
        <action>Create tracking file for PR analysis</action>
        <file>.roo/tmp/release-notes/temp_pr_analysis_v[version].md</file>
        <details>
          Create the temp directory and file to track PR analysis results.
          Each PR analysis will be appended to this file as it completes.
        </details>
      </initialization>
      
      <inline_analysis_workflow>
        <for_each>PR in list</for_each>
        <action>Analyze PR inline using gh CLI</action>
        <steps>
          <step number="1">
            <action>Fetch PR details</action>
            <command>gh pr view [NUMBER] --repo RooCodeInc/Roo-Code --json number,title,author,mergedAt,labels,body,url</command>
          </step>
          <step number="2">
            <action>Extract linked issues from PR body</action>
            <details>Parse the PR body for issue references (Fixes #123, Closes #456, etc.)</details>
          </step>
          <step number="3">
            <action>Fetch linked issue details if present</action>
            <command>gh issue view [ISSUE_NUMBER] --repo RooCodeInc/Roo-Code --json number,title,author,body</command>
          </step>
          <step number="4">
            <action>Categorize the change</action>
            <categories>
              <category>Feature - New functionality</category>
              <category>QOL Improvement - UI/UX enhancement</category>
              <category>Bug Fix - Resolves an issue</category>
              <category>Provider Update - API provider changes</category>
            </categories>
          </step>
          <step number="5">
            <action>Identify documentation needs</action>
            <flags>
              <flag name="docs-new">Completely new feature requiring new documentation page</flag>
              <flag name="docs-update">Existing documentation needs updating</flag>
              <flag name="docs-example">New examples or use cases to add</flag>
              <flag name="docs-migration">Migration guide needed for breaking changes</flag>
            </flags>
          </step>
          <step number="6">
            <action>Append analysis to tracking file</action>
            <file>.roo/tmp/release-notes/temp_pr_analysis_v[version].md</file>
          </step>
        </steps>
      </inline_analysis_workflow>
      
      <output_format>
## PR #[number]: [Title]

**Author**: [username]
**Linked Issues**: #[issue] (reporter: [username])
**Category**: [Category]
**User Impact**: [Benefit description]
**Contributors**: [list]
**Documentation Needs**: [none|docs-new|docs-update|docs-example|docs-migration]
**Documentation Notes**: [If applicable, what needs documenting]

---
      </output_format>
      
      <processing_guidance>
        <note>Process PRs sequentially, appending each analysis to the tracking file</note>
        <note>For large PR lists (10+), provide progress updates every 5 PRs</note>
        <note>If a PR fetch fails, note the error and continue with remaining PRs</note>
      </processing_guidance>
    </phase>
    
    <phase name="changelog_alignment">
      <description>Align the working PR set with the repository changelog for the selected version(s)</description>
      <step number="1">
        <action>Fetch changelog content for v[VERSION]</action>
        <command><![CDATA[
# Get the release body which contains the changelog
gh release view vX.Y.Z --repo RooCodeInc/Roo-Code --json body | jq -r '.body'
        ]]></command>
        <note>The release body contains the curated list of changes for this version</note>
      </step>

      <step number="1a">
        <action>Extract hero image URL candidates from release body and changelog; persist</action>
        <commands>
          <save_body_to_file><![CDATA[
# Save release body to a temp file for reuse
mkdir -p .roo/tmp/release-notes
gh release view vX.Y.Z --repo RooCodeInc/Roo-Code --json body --jq '.body' > .roo/tmp/release-notes/changelog_vX.Y.Z.md
          ]]></save_body_to_file>
          <fetch_changelog><![CDATA[
# Fetch CHANGELOG.md from main branch FIRST for hero image discovery.
# Hero images are often added retroactively after release, so the current main
# branch has the most up-to-date images. Only fall back to the release tag if main fails.
TMP_DIR=".roo/tmp/release-notes"
CHANGELOG_TAG_FILE="$TMP_DIR/CHANGELOG_vX.Y.Z.md"
SECTION_FILE="$TMP_DIR/CHANGELOG_section_vX.Y.Z.md"
# Try main first (has retroactively-added hero images)
if gh api "repos/RooCodeInc/Roo-Code/contents/CHANGELOG.md" --jq '.content' >/tmp/chlog64.txt 2>/dev/null; then
  base64 -D </tmp/chlog64.txt > "$CHANGELOG_TAG_FILE" || true
# Fallback to tag if main fails
elif gh api "repos/RooCodeInc/Roo-Code/contents/CHANGELOG.md?ref=vX.Y.Z" --jq '.content' >/tmp/chlog64.txt 2>/dev/null; then
  base64 -D </tmp/chlog64.txt > "$CHANGELOG_TAG_FILE" || true
else
  : > "$CHANGELOG_TAG_FILE"
fi
# Extract the vX.Y.Z section if present
# CRITICAL: If the version header is not found, create an EMPTY section file.
# Do NOT fall back to the entire changelog—that would pull images from other versions.
if [ -s "$CHANGELOG_TAG_FILE" ]; then
  START_LINE=$(grep -nE '^[#]{2,3}[[:space:]]*\[?v?X\.Y\.Z\]?' "$CHANGELOG_TAG_FILE" | head -n1 | cut -d: -f1 || true)
  if [ -n "${START_LINE:-}" ]; then
    END_LINE=$(tail -n +"$((START_LINE+1))" "$CHANGELOG_TAG_FILE" | grep -nE '^[#]{2,3}[[:space:]]*' | head -n1 | cut -d: -f1 || true)
    if [ -n "${END_LINE:-}" ]; then
      END_ABS=$((START_LINE + END_LINE - 1))
      sed -n "${START_LINE},${END_ABS}p" "$CHANGELOG_TAG_FILE" > "$SECTION_FILE"
    else
      tail -n +"$START_LINE" "$CHANGELOG_TAG_FILE" > "$SECTION_FILE"
    fi
  else
    # Version header not found—create empty section to avoid pulling images from other versions
    : > "$SECTION_FILE"
  fi
else
  : > "$SECTION_FILE"
fi
          ]]></fetch_changelog>
          <extract_candidates><![CDATA[
# Build candidate list ONLY from the extracted changelog section for the target version.
# Do NOT extract from the full release body—it often contains the entire changelog,
# which would pull images from unrelated versions.
CANDIDATES_FILE=".roo/tmp/release-notes/image_candidates_vX.Y.Z.txt"
SECTION_FILE=".roo/tmp/release-notes/CHANGELOG_section_vX.Y.Z.md"
: > "$CANDIDATES_FILE"

# From CHANGELOG section markdown images (absolute or relative)
grep -Eo '!\[[^]]*\]\(([^)]+)\)' "$SECTION_FILE" 2>/dev/null \
  | sed -E 's/.*\(([^)]+)\).*/\1/' | grep -Ei '\.(png|jpe?g|gif|webp)' >> "$CANDIDATES_FILE" || true

# From CHANGELOG section bare URLs (absolute or relative)
grep -Eo 'https?://[^ )]+' "$SECTION_FILE" 2>/dev/null | grep -Ei '\.(png|jpe?g|gif|webp)' >> "$CANDIDATES_FILE" || true
grep -Eo '(/[^ )]+|[A-Za-z0-9_./-]+)\.(png|jpe?g|gif|webp)' "$SECTION_FILE" 2>/dev/null >> "$CANDIDATES_FILE" || true

# Deduplicate
if [ -s "$CANDIDATES_FILE" ]; then
  sort -u "$CANDIDATES_FILE" > "$CANDIDATES_FILE.tmp" && mv "$CANDIDATES_FILE.tmp" "$CANDIDATES_FILE"
fi
          ]]></extract_candidates>
        </commands>
        <output>
          <file>.roo/tmp/release-notes/image_candidates_v[version].txt</file>
          <content>One URL or relative path per line; may be empty if no images present</content>
        </output>
      </step>

      <step number="1b">
        <action>Resolve hero image from discovered candidates (no placeholder if none exist)</action>
        <command><![CDATA[
VERSION="X.Y.Z"
CANDIDATES_FILE=".roo/tmp/release-notes/image_candidates_v$VERSION.txt"
FRONTMATTER_FILE=".roo/tmp/release-notes/frontmatter_image_v$VERSION.txt"

# Try the first candidate URL/path as the hero image source
mkdir -p "static/img/v$VERSION"
OUT="static/img/v$VERSION/v$VERSION.png"
SRC="$(head -n1 "$CANDIDATES_FILE")"

# If SRC is a relative docs path, prefix it with the raw GitHub base for Roo-Code
if echo "$SRC" | grep -qE '^(https?://)'; then
  URL="$SRC"
else
  # Treat as repository-relative path; adjust as needed if release assets move
  URL="https://raw.githubusercontent.com/RooCodeInc/Roo-Code/main/$SRC"
fi

curl -L "$URL" -o "$OUT" || true
if [ -s "$OUT" ]; then
  echo "/img/v$VERSION/v$VERSION.png" > "$FRONTMATTER_FILE"
fi
        ]]></command>
        <notes>
          - Skip hero image download entirely when no candidates were discovered
          - When candidates exist, attempt to download the first one and persist it as /img/v$VERSION/v$VERSION.png
          - If download fails or the file is empty, do not set a frontmatter image
          - Prefer PNG when multiple candidates are present (candidates list should already be filtered/ordered)
        </notes>
      </step>

      <step number="2">
        <action>Extract version section lines from changelog_source</action>
        <details>
          If using Release body: treat the entire body as the v[VERSION] section.
          If using CHANGELOG.md: isolate the v[VERSION] section by heading match:
          - Headings commonly appear as "## vX.Y.Z", "## X.Y.Z", or "## [X.Y.Z]".
        </details>
        <parsing>
          <regex>Detect PR references as: /#(\d{1,7})/g</regex>
          <heuristics>
  Purpose: Count changelog bullets without explicit PR numbers as "referenced" when they confidently map to a PR.
  Matching algorithm:
  - Normalize both bullet text and PR titles:
    - lowercase; remove punctuation; strip prefixes like "fix:", "feat:", "add:", "improve:", "chore:", "refactor:"
    - remove parentheticals such as "(thanks @user!)", "(PR by @user)", "(#1234 ...)"
    - collapse whitespace
  - Tokenize and compute token-overlap score = |intersection(tokens)| / |union(tokens)|
  - Author signal: if bullet contains "thanks @user", "by @user", or "PR by @user" and that user equals the PR author or credited issue reporter, add +0.20 to score
  - Keyword boost: +0.05 when provider/model/domain keywords (e.g., OpenAI, Claude, Grok, Chutes, Qwen, LongCat, etc.) appear in both
  Confidence thresholds:
  - score >= 0.65 (after boosts) -> linked (confident). Treat as changelog-referenced.
  - 0.45 <= score < 0.65 OR multiple candidates within 0.05 -> ambiguous (needs review)
  - score < 0.45 -> unlinked
  Tie-breakers: higher score; if within 0.02 then same author; then closer merge date to release date; then lowest PR number
  Edge case: If bullet credits exactly one username and exactly one PR in the window has that author, accept with score >= 0.50 (confidence="author-boost")
  Implementation notes:
  - Match only against PRs fetched for the version's date window
  - Persist mapping bullet_text -> { prNumber, confidenceScore, rationaleSignals[] } and use it to compute linked/ambiguous/unlinked counts
          </heuristics>
        </parsing>
      </step>
      
      <step number="2a">
        <action>Supplement candidate PR set with changelog-referenced PRs not in fetched list</action>
        <details>
          - Identify referenced PR numbers from step 2 that are missing from .roo/tmp/release-notes/temp_pr_analysis_v[version].md
          - For each missing PR, fetch details and analyze inline (same process as pr_processing phase)
          - Mark these as out_of_range if their mergedAt is outside the computed date window
          - Append analysis to the tracking file
        </details>
        <inline_analysis>
          <for_each>Missing PR number referenced in changelog</for_each>
          <command>gh pr view [NUMBER] --repo RooCodeInc/Roo-Code --json number,title,author,mergedAt,labels,body,url</command>
          <process>
            - Fetch PR details
            - Extract linked issues
            - Categorize change
            - Identify documentation needs
            - Append to .roo/tmp/release-notes/temp_pr_analysis_v[version].md
          </process>
        </inline_analysis>
      </step>
      
      <step number="2b">
        <action>Detect out-of-range referenced PRs</action>
        <output>
          <metric name="out_of_range_count">Number of referenced PRs with mergedAt outside the YYYY-MM-DD..YYYY-MM-DD window</metric>
        </output>
      </step>
      
      <step number="3">
        <action>Partition PRs using changelog</action>
        <result>
          <in_changelog>PRs explicitly referenced or confidently matched to changelog lines</in_changelog>
          <excluded>PRs not referenced or ambiguous</excluded>
        </result>
        <analysis>
          Provide a brief summary:
          - Included: [IN_COUNT] PRs
          - Excluded: [EX_COUNT] PRs
          Possible reasons for exclusion:
          - Not mentioned in changelog
          - Combined under a meta PR
          - Documentation-only or infra work
          - Outside computed date window
          - Title did not match any changelog line
        </analysis>
      </step>

      <step number="4">
        <action>Ask for inclusion policy</action>
        <tool>ask_followup_question</tool>
        <template><![CDATA[
<ask_followup_question>
<question>Changelog alignment for v[VERSION]: [IN_COUNT] PRs referenced, [EX_COUNT] not referenced. How should I proceed?</question>
<follow_up>
<suggest>Only include the PRs referenced in the changelog</suggest>
<suggest>Include all PRs from the date range</suggest>
<suggest>Review each excluded PR one by one so I can choose</suggest>
</follow_up>
</ask_followup_question>
        ]]></template>
        <critical>Do not proceed until one of the provided options is selected.</critical>
      </step>

      <step number="5" optional="true">
        <when>User selects per-PR review</when>
        <action>Iteratively review excluded PRs</action>
        <loop>
          For each PR in the excluded set:
          - Show title, author, brief labels, and a 1-2 sentence user-impact summary
          - Ask: include this PR?
          - Options: "Yes, include this PR" or "No, skip this PR"
          - Build the final inclusion set as (in_changelog U user_selected_inclusions)
        </loop>
        <template><![CDATA[
<ask_followup_question>
<question>Include PR #[NUMBER] - [TITLE]? Short analysis: [WHY IT MATTERS].</question>
<follow_up>
<suggest>Yes, include this PR</suggest>
<suggest>No, skip this PR</suggest>
</follow_up>
</ask_followup_question>
        ]]></template>
        <completion>After the loop, proceed with the finalized PR set.</completion>
      </step>
      
      <handoff>Proceed to feature selection using the finalized PR set. Persist included/excluded lists to .roo/tmp/release-notes/temp_pr_inclusion_v[version].json for downstream filtering.</handoff>
    </phase>

    <phase name="compilation">
      <step number="1">
        <action>Read and organize PR findings (filtered to finalized inclusion set)</action>
        <inputs>
          <file>.roo/tmp/release-notes/temp_pr_analysis_v[version].md</file>
          <file optional="true">.roo/tmp/release-notes/temp_pr_inclusion_v[version].json</file>
        </inputs>
        <precondition>
          - Inclusion policy required: If .roo/tmp/release-notes/temp_pr_inclusion_v[version].json does not exist, you MUST execute the changelog_alignment phase now to obtain an inclusion decision, then retry this step.
        </precondition>
        <filtering>
          Include only PRs listed in "included" from .roo/tmp/release-notes/temp_pr_inclusion_v[version].json. Do not fall back to using all analyzed PRs without an explicit inclusion policy.
        </filtering>
        <categories>Features, QOL Improvements, Bug Fixes, Provider Updates</categories>
        <critical>QOL Improvements MUST come before Bug Fixes</critical>
        <user_facing_rewrite>
          <principles>
            <principle priority="CRITICAL">Rewrite every item into a user-facing statement; do not ship raw PR titles.</principle>
            <principle priority="HIGH">Lead with the user symptom or capability, then the fix/change, and where it appears in the UI or workflow.</principle>
            <principle priority="HIGH">Avoid backend or protocol jargon unless it is the exact UI label the user clicks.</principle>
          </principles>
          <template>
            <problem>What users saw or could not do (include the surface area: page, menu, toggle, dialog, workflow).</problem>
            <change>What changed in one clause (fixed/added/improved).</change>
            <benefit>Why it matters to the user now (clearer, faster, unblocked, safer).</benefit>
            <example>
              <before>Always show tool protocol selector for OpenAI-compatible providers</before>
              <after>Fixes an issue where the pulldown that lets you choose how Roo communicates with the API (Native vs XML) in the Advanced section of the Providers settings would sometimes fail to appear when using the OpenAI Compatible provider.</after>
            </example>
          </template>
          <checks>
            <check>Each bullet must answer: what changed, where the user sees it, why it matters.</check>
            <check>Replace internal terms (e.g., "protocol selector") with the on-screen wording users see.</check>
            <check>For fixes, start with "Fixes an issue where …" or "Resolves a problem where …" instead of echoing PR titles.</check>
          </checks>
        </user_facing_rewrite>
      </step>
      
      <step number="2">
        <action>Confirm feature highlighting with user</action>
        <tool>ask_followup_question</tool>
        <template>
I've analyzed all PRs for v[VERSION]. Here are the changes I found:

**Major Features:**
[List major features with brief descriptions]

**Bug Fixes:** [COUNT] fixes
**QOL Improvements:** [COUNT] improvements
**Other Changes:** [COUNT] items

Which features should I highlight with expanded sections in the release notes?
        </template>
        <gating>
          <rule>Do not proceed until an explicit selection from the provided options is received.</rule>
          <rule>On freeform responses, re-ask with reformulated options derived from the user's input until a provided option is chosen.</rule>
        </gating>
        <critical>Must get explicit confirmation before writing notes; see user_interactions.feature_selection.gating_rules</critical>
      </step>
      
      <step number="3">
        <action>Create release notes file</action>
        <format>
          For patch versions (X.Y.Z): docs/update-notes/vX.Y.Z.mdx
          For minor/major summaries (X.Y): docs/update-notes/vX.Y.mdx
        </format>
        <frontmatter_image>
          <source>.roo/tmp/release-notes/frontmatter_image_v[version].txt</source>
          <behavior>
            - If the source file exists and starts with "/img/", set frontmatter "image" to that value
            - Otherwise, OMIT the frontmatter "image" field entirely (no placeholder)
          </behavior>
        </frontmatter_image>
        <inline_hero_image>
          <source>.roo/tmp/release-notes/frontmatter_image_v[version].txt</source>
          <insertion_point>Immediately after the intro summary sentence below the H1 title</insertion_point>
          <behavior>
            - If the persisted path starts with "/img/", insert an HTML image tag under the intro paragraph
            - Use the exact path value from the source file for src
            - Follow .roorules Image Tag Format and use width="600"
            - If there is no persisted path file OR it does not start with "/img/", skip inline insertion
          </behavior>
          <html_snippet><![CDATA[
<img src="[FRONTMATTER_IMAGE_PATH]" alt="Roo Code v[VERSION] Release" width="600" />
          ]]></html_snippet>
        </inline_hero_image>
      </step>
      
      <step number="4">
        <action>For patch releases: Get user confirmation</action>
        <critical>
          Do NOT update combined notes until user confirms patch notes are final
        </critical>
      </step>
      
      <step number="5">
        <action>Update documentation indexes</action>
        <files>
          - index.md (chronological list)
          - sidebars.ts (navigation)
          - Combined notes for patch releases (ONLY after confirmation)
        </files>
      </step>
      
      <step number="6">
        <action>Summarize documentation update needs</action>
        <when>If any documentation flags were identified during PR analysis</when>
        <output>
          Present a summary of documentation needs to the user:
          - List items flagged as docs-new (new features needing new pages)
          - List items flagged as docs-update (existing pages needing updates)
          - List items flagged as docs-example (new examples needed)
          - List items flagged as docs-migration (migration guides needed)
          
          The user can then follow up with documentation-writer mode separately if desired.
        </output>
        <template><![CDATA[
**Documentation Update Summary:**

The following items may need documentation updates:

**New Documentation Needed:**
- [Feature name]: [Brief description of what needs documenting]

**Existing Docs Updates:**
- [Page/feature]: [What needs updating]

**Examples Needed:**
- [Feature]: [Example scenarios to add]

**Migration Guides:**
- [Breaking change]: [Migration path to document]

To create these documentation updates, you can start a new task with documentation-writer mode.
        ]]></template>
      </step>
      
      <step number="7">
        <action>Cleanup temporary files</action>
        <details>Delete .roo/tmp/release-notes/* (temp_pr_analysis_v[version].md, temp_pr_list_v[version].md, temp_pr_inclusion_v[version].json) after notes are finalized.</details>
      </step>
    </phase>
  </main_workflow>

  <special_workflows>
    <workflow name="discord_only">
      <description>Generate Discord format from existing release files, preserving original structure</description>
      <core_principle priority="critical">
        Preserve original headings and section structure from source docs exactly.
        Do NOT rename, merge, or reorganize sections.
      </core_principle>
      <transformations>
        - Remove PR links and numbers from all content
        - Convert /path to https://docs.roocode.com/path
        - Convert "* " list bullets to "- " bullets
        - Remove inline hero images
        - Add footer link with markdown format
        - Wrap entire output in markdown code block
      </transformations>
      <formatting_rules>
        <rule>Title format: # Roo Code X.Y.Z Release Updates (no emoji)</rule>
        <rule>Preserve all section headings EXACTLY as in source docs</rule>
        <rule>Preserve section order EXACTLY as in source docs</rule>
        <rule>Copy all bullet points exactly (only change * to -)</rule>
        <rule>No version numbers in body text (only header/footer)</rule>
        <rule>No "Happy coding!" or similar closings</rule>
        <rule>Footer: See full release notes [vX.Y.Z](link)</rule>
      </formatting_rules>
      <output>Formatted text wrapped in ```markdown code block (no files created)</output>
    </workflow>

    <workflow name="discord_combined">
      <description>Generate combined Discord format from multiple release files, preserving original structure</description>
      <core_principle priority="critical">
        Preserve original headings and section structure from source docs exactly.
        Merge content from same-named sections across versions.
      </core_principle>
      <steps>
        <step>Read all specified release note files</step>
        <step>Preserve all section headings exactly as they appear</step>
        <step>Merge content from same-named sections across versions</step>
        <step>Apply minimal Discord transformations</step>
      </steps>
      <formatting_rules>
        <rule>Title format: # Roo Code X.Y.Z-X.Y.Z Release Updates (no emoji)</rule>
        <rule>Preserve all section headings EXACTLY as in source docs</rule>
        <rule>Footer with links to each version: [vX.Y.Z](link) | [vX.Y.Z](link)</rule>
        <rule>Wrap entire output in ```markdown code block</rule>
      </formatting_rules>
      <output>Combined formatted text (no files created)</output>
    </workflow>

    <workflow name="reddit_only">
      <description>Generate Reddit format from existing release files, preserving original structure</description>
      <core_principle priority="critical">
        Preserve original headings and section structure from source docs exactly.
        Do NOT rename, merge, or reorganize sections.
      </core_principle>
      <transformations>
        - Remove all PR links and numbers
        - Convert /path to https://docs.roocode.com/path
        - Convert "* " list bullets to "- " bullets
        - Remove inline hero images
        - Wrap entire output in markdown code block
      </transformations>
      <formatting_rules>
        <rule>Title: Plain text with key features separated by pipes</rule>
        <rule>Preserve all section headings EXACTLY as in source docs</rule>
        <rule>Preserve section order EXACTLY as in source docs</rule>
        <rule>No @everyone</rule>
        <rule>Footer: See full release notes [vX.Y.Z](link)</rule>
      </formatting_rules>
      <output>Formatted text wrapped in ```markdown code block (no files created)</output>
    </workflow>

    <workflow name="latest">
      <description>Auto-detect missing versions</description>
      <steps>
        <step>List existing docs files in docs/update-notes</step>
        <step>Get recent releases from GitHub with full details</step>
        <step>Identify missing versions (releases without docs)</step>
        <step>Ask which to process</step>
      </steps>
      <commands>
        <get_existing_docs><![CDATA[
# Get existing documentation files
ls docs/update-notes | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?\.(md|mdx)$' | sed -E 's/\.(md|mdx)$//'
        ]]></get_existing_docs>
        
        <get_releases_with_details><![CDATA[
# Get recent releases with full details in JSON array
echo "["; first=1; \
for tag in $(gh release list --repo RooCodeInc/Roo-Code --limit 20 --json tagName --jq '.[].tagName'); do
  if [ $first -eq 0 ]; then echo ","; fi
  gh release view "$tag" --repo RooCodeInc/Roo-Code --json tagName,targetCommitish,publishedAt
  first=0
done; \
echo "]"
        ]]></get_releases_with_details>
      </commands>
      <process>
        Compare the release list with existing docs to identify missing versions.
        Present the missing versions with their publish dates for user selection.
      </process>
      <handoff>After the user selects versions to process, use the simplified PR extraction for each selected version</handoff>
    </workflow>
  </special_workflows>

  <simplified_pr_extraction_guide>
    <overview>
      The PR extraction uses release timestamps to find all PRs merged between releases.
      This is simple, reliable, and captures all changes in a single command.
    </overview>
    
    <the_command><![CDATA[
# Replace X.Y.Z with the actual version number
TAG_INPUT="X.Y.Z"; TAG="v$(echo "$TAG_INPUT" | sed 's/^v//')"; \
END=$(gh release view "$TAG" --repo RooCodeInc/Roo-Code --json publishedAt --jq '.publishedAt'); \
START=$(gh release list --repo RooCodeInc/Roo-Code --limit 1000 --json tagName,publishedAt --jq '[.[]|{tag:.tagName,at:.publishedAt}]|sort_by(.at)|(map(.tag)|index("'"$TAG"'")) as $i | .[($i-1)].at'); \
gh pr list --repo RooCodeInc/Roo-Code --state merged --base main --limit 1000 \
  --json number,title,author,url,mergedAt \
  --jq 'map(select(.mergedAt >= "'"$START"'" and .mergedAt <= "'"$END"'")) | sort_by(.mergedAt)[] | [.number,.mergedAt,.author.login,.title,.url] | @tsv'
    ]]></the_command>
    
    <what_it_does>
      1. Gets the release timestamp for your version
      2. Finds the previous release's timestamp
      3. Fetches ALL PRs merged between those timestamps
      4. Returns them sorted by merge date with full metadata
    </what_it_does>
  </simplified_pr_extraction_guide>

  <critical_rules>
    <rule priority="CRITICAL">
      Date format is YYYY-MM-DD (ISO 8601) where MM is month (01-12)
    </rule>
    <rule priority="CRITICAL">
      All PR analysis happens inline within this task - do not spawn subtasks
    </rule>
    <rule priority="CRITICAL">
      Use the simplified PR extraction command for consistent results
    </rule>
    <rule priority="HIGH">
      Acknowledge PR author AND issue reporter, unless the username is on the release-notes "thank you" exclusion list.
      If all candidate acknowledgements are excluded, omit the thanks parenthetical entirely.
    </rule>
    <rule priority="HIGH">
      Focus on user benefits, not technical implementation
    </rule>
    <rule priority="HIGH">
      QOL Improvements section MUST come before Bug Fixes
    </rule>
    <rule priority="HIGH">
      When the user asks for Discord or Reddit notes, output both variants in a single response
    </rule>
  </critical_rules>
</workflow_instructions>
