<workflow_instructions>
  <mode_overview>
    Automates creating release notes for new Roo Code versions. Fetches pull requests
    from GitHub, analyzes changes, generates user-focused notes, and handles Discord
    formatting. Supports version-only requests and auto-detection of missing versions.
  </mode_overview>

  <entry_patterns>
    <pattern type="create_new">
      <trigger>Create release notes for X.Y.Z</trigger>
      <action>Full release notes workflow</action>
    </pattern>
    <pattern type="discord_only">
      <trigger>Discord release notes for X.Y.Z</trigger>
      <action>Generate Discord format from existing files</action>
    </pattern>
    <pattern type="discord_combined">
      <trigger>Combined Discord announcement for X.Y.Z, X.Y.Z, and X.Y.Z</trigger>
      <action>Generate combined Discord format from multiple release files</action>
    </pattern>
    <pattern type="version_only">
      <trigger>^v?[\d.]+$</trigger>
      <action>Extract PR list and ask how to proceed</action>
    </pattern>
    <pattern type="latest">
      <trigger>latest</trigger>
      <action>Auto-detect missing versions from changelog</action>
    </pattern>
  </entry_patterns>

  <critical_date_format>
    <format>ISO 8601: YYYY-MM-DD</format>
    <specification>
      - YYYY = 4-digit year (e.g., 2025)
      - MM = 2-digit MONTH (01-12) - NOT the day!
      - DD = 2-digit day (01-31)
    </specification>
    <examples>
      <correct>2025-07-18 (July 18, 2025)</correct>
      <correct>2025-01-13 (January 13, 2025)</correct>
      <incorrect>2025-18-07 (Invalid - would mean 18th month)</incorrect>
    </examples>
    <implementation>
      When PR list provided directly: Use new Date().toISOString().split('T')[0] (UTC)
      Note: toISOString returns UTC; do not convert to local time to avoid off-by-one day differences.
    </implementation>
  </critical_date_format>

  <main_workflow>
    <phase name="initialization">
      <step number="1">
        <action>Analyze request type and route to appropriate workflow</action>
        <decision_tree>
          <if condition="latest">Execute latest_version_detection</if>
          <if condition="discord_only">Execute discord_workflow</if>
          <if condition="version_only">Execute pr_extraction_workflow</if>
          <else>Continue with standard workflow</else>
        </decision_tree>
      </step>
      
      <step number="2">
        <action>Initialize tracking</action>
        <tool>update_todo_list</tool>
        <todos>
          - Determine version range
          - Fetch PRs (if needed)
          - Process and analyze PRs
          - Create documentation files
          - Update indexes and sidebars
          - Handle user review
        </todos>
      </step>
    </phase>

    <phase name="data_collection">
      <step number="1">
        <action>Determine version range</action>
        <tool>list_files in docs/update-notes</tool>
      </step>
      
      <step number="2" optional="true">
        <action>Handle user-provided PR list</action>
        <when>User provides PR numbers directly</when>
        <critical>Validate date format (MM is month, not day)</critical>
      </step>
      
      <step number="3">
        <action>Fetch PRs from GitHub</action>
        <skip_if>User provided PR list</skip_if>
        <commands>
          <get_release_published_date><![CDATA[
gh release view vX.Y.Z --repo RooCodeInc/Roo-Code --json publishedAt | jq -r '.publishedAt'
          ]]></get_release_published_date>
          <get_tag_date><![CDATA[
gh api repos/RooCodeInc/Roo-Code/git/refs/tags/vX.Y.Z --jq '.object.sha' | xargs -I {} gh api repos/RooCodeInc/Roo-Code/git/commits/{} --jq '.committer.date'
          ]]></get_tag_date>
          <search_prs><![CDATA[
gh pr list --repo RooCodeInc/Roo-Code --state merged --search "merged:YYYY-MM-DD..YYYY-MM-DD" --json number,title,author,mergedAt --limit 1000
          ]]></search_prs>
        </commands>
      </step>
    </phase>

    <phase name="pr_processing">
      <initialization priority="CRITICAL">
        <action>Create .roo/tmp/release-notes/temp_pr_analysis.md</action>
        <details>
          Parent task MUST create this file (and .roo/tmp/release-notes/temp_pr_inclusion.json, .roo/tmp/release-notes/temp_pr_list.md if needed) before ANY subtasks.
          Subtasks will ONLY append using insert_content.
          Temp files live under .roo/tmp/release-notes/
        </details>
      </initialization>
      
      <subtask_pattern>
        <for_each>PR in list</for_each>
        <action>Create investigation subtask using new_task tool</action>
        <implementation>
          <tool>new_task</tool>
          <mode>release-notes-writer</mode>
          <description>
            For each PR in the fetched or provided list, create a separate subtask
            using the new_task tool. Each subtask investigates one PR independently.
          </description>
          <iteration_approach>
            Process PRs sequentially or in batches, creating a new_task for each PR number.
            Wait for all subtasks to complete before proceeding to compilation phase.
          </iteration_approach>
        </implementation>
        <message_template><![CDATA[
Investigate PR #[number] for release notes v[version].
1. Get PR details (gh pr view)
2. Extract linked issues
3. Get issue details
4. Categorize change
5. Identify documentation needs (new features, behavior changes, deprecations)
6. Append to .roo/tmp/release-notes/temp_pr_analysis.md using insert_content line 0

Include documentation flags:
- docs-new: Completely new feature
- docs-update: Existing docs need updating
- docs-example: New examples needed
- docs-migration: Breaking changes

CRITICAL: Never create/overwrite files, only append.
        ]]></message_template>
        <todos_template><![CDATA[
[ ] Fetch PR #[number] details using gh pr view
[ ] Extract linked issues from PR body
[ ] Get issue details for each linked issue
[ ] Categorize the change (Feature/QOL/Bug Fix/Provider Update)
[ ] Identify documentation needs
[ ] Write analysis to .roo/tmp/release-notes/temp_pr_analysis.md
        ]]></todos_template>
      </subtask_pattern>
      
      <output_format><![CDATA[
## PR #[number]: [Title]

**Author**: [username]
**Linked Issues**: #[issue] (reporter: [username])
**Category**: [Category]
**User Impact**: [Benefit description]
**Contributors**: [list]
**Documentation Needs**: [none|docs-new|docs-update|docs-example|docs-migration]
**Documentation Notes**: [If applicable, what needs documenting]

---
      ]]></output_format>
      
      <subtask_creation_example>
        <description>Example of creating subtasks for a PR list</description>
        <scenario>Given PRs: #1234, #1235, #1236 for version 3.20.1</scenario>
        <implementation><![CDATA[
<!-- For each PR, create a subtask like this: -->
<new_task>
<mode>release-notes-writer</mode>
<message>Investigate PR #1234 for release notes v3.20.1.
1. Get PR details (gh pr view)
2. Extract linked issues
3. Get issue details
4. Categorize change
5. Identify documentation needs (new features, behavior changes, deprecations)
6. Append to .roo/tmp/release-notes/temp_pr_analysis.md using insert_content line 0

Include documentation flags:
- docs-new: Completely new feature
- docs-update: Existing docs need updating
- docs-example: New examples needed
- docs-migration: Breaking changes

CRITICAL: Never create/overwrite files, only append.</message>
<todos>
[ ] Fetch PR #1234 details using gh pr view
[ ] Extract linked issues from PR body
[ ] Get issue details for each linked issue
[ ] Categorize the change (Feature/QOL/Bug Fix/Provider Update)
[ ] Identify documentation needs
[ ] Write analysis to .roo/tmp/release-notes/temp_pr_analysis.md
</todos>
</new_task>

<!-- Repeat for PR #1235, #1236, etc. -->
        ]]></implementation>
        <critical_notes>
          - Parent task must create temp_pr_analysis.md BEFORE creating any subtasks
          - Each subtask gets its own new_task invocation
          - Subtasks run in the same release-notes-writer mode
          - Parent waits for all subtasks to complete before compilation
        </critical_notes>
      </subtask_creation_example>
    </phase>
    
    <phase name="changelog_alignment">
      <description>Align the working PR set with the repository changelog for the selected version(s)</description>
      <step number="1">
        <action>Fetch changelog content for v[VERSION] (Release body first, then CHANGELOG.md at tag, then PR scan as last resort)</action>
        <commands>
          <strategy priority="1"><![CDATA[
gh release view vX.Y.Z --repo RooCodeInc/Roo-Code --json body | jq -r '.body'
          ]]></strategy>
          <strategy priority="2"><![CDATA[
# Fallback to CHANGELOG at the tag commit
gh api repos/RooCodeInc/Roo-Code/contents/CHANGELOG.md?ref=vX.Y.Z --jq '.content' | base64 -d
          ]]></strategy>
          <strategy priority="3"><![CDATA[
# Fallback to main branch CHANGELOG if tag content unavailable
gh api repos/RooCodeInc/Roo-Code/contents/CHANGELOG.md --jq '.content' | base64 -d
          ]]></strategy>
          <strategy priority="4"><![CDATA[
# Last resort: scan merged PRs in the version window for ones that modified CHANGELOG.md
# Requires YYYY-MM-DD..YYYY-MM-DD boundaries computed earlier
gh pr list --repo RooCodeInc/Roo-Code --state merged --search "merged:YYYY-MM-DD..YYYY-MM-DD" --json number --limit 1000 \
| jq '.[].number' \
| xargs -I {} gh pr view {} --json files \
| jq -r 'select(.files[].path=="CHANGELOG.md") | .number'
          ]]></strategy>
        </commands>
        <dependency_note>Use the first non-empty result as changelog_source. Prefer the Release body; only fall back to file or PR scan if empty or unavailable.</dependency_note>
        <critical>Do not attempt to locate a "changelog PR" when a Release body or CHANGELOG.md content is available.</critical>
      </step>

      <step number="2">
        <action>Extract version section lines from changelog_source</action>
        <details>
          If using Release body: treat the entire body as the v[VERSION] section.
          If using CHANGELOG.md: isolate the v[VERSION] section by heading match:
          - Headings commonly appear as "## vX.Y.Z", "## X.Y.Z", or "## [X.Y.Z]".
        </details>
        <parsing>
          <regex>Detect PR references as: /#(\d{1,7})/g</regex>
          <heuristics>
            - If a bullet has no explicit PR number, attempt fuzzy matching to PR titles
            - If ambiguous, mark as "unlinked" and exclude by default pending user choice
          </heuristics>
        </parsing>
      </step>
      
      <step number="2a">
        <action>Supplement candidate PR set with changelog-referenced PRs not in fetched list and spawn analysis subtasks</action>
        <details>
          - Identify referenced PR numbers from step 2 that are missing from .roo/tmp/release-notes/temp_pr_analysis.md
          - For each missing PR, fetch details and create a new investigation subtask (same pattern as pr_processing) to append analysis to temp_pr_analysis.md
          - Mark these as out_of_range if their mergedAt is outside the computed date window
          - Wait for all spawned subtasks to complete before proceeding
        </details>
        <commands>
          <fetch><![CDATA[
# For each referenced PR number N not present in .roo/tmp/release-notes/temp_pr_analysis.md:
gh pr view N --repo RooCodeInc/Roo-Code --json number,title,author,mergedAt,labels,files
          ]]></fetch>
          <spawn_subtask><![CDATA[
<new_task>
<mode>release-notes-writer</mode>
<message>Investigate PR #[NUMBER] (changelog-referenced, possibly out of original range) for release notes v[version]. Follow standard analysis and append to .roo/tmp/release-notes/temp_pr_analysis.md.</message>
<todos>
[ ] Fetch PR #[NUMBER] details using gh pr view
[ ] Extract linked issues from PR body
[ ] Get issue details for each linked issue
[ ] Categorize the change (Feature/QOL/Bug Fix/Provider Update)
[ ] Identify documentation needs
[ ] Write analysis to .roo/tmp/release-notes/temp_pr_analysis.md
</todos>
</new_task>
          ]]></spawn_subtask>
      </step>
      
      <step number="2b">
        <action>Detect out-of-range referenced PRs</action>
        <output>
          <metric name="out_of_range_count">Number of referenced PRs with mergedAt outside the YYYY-MM-DD..YYYY-MM-DD window</metric>
        </output>
      </step>
      
      <step number="3">
        <action>Partition PRs using changelog</action>
        <result>
          <in_changelog>PRs explicitly referenced or confidently matched to changelog lines</in_changelog>
          <excluded>PRs not referenced or ambiguous</excluded>
        </result>
        <analysis>
          Provide a brief summary:
          - Included: [IN_COUNT] PRs
          - Excluded: [EX_COUNT] PRs
          Possible reasons for exclusion:
          - Not mentioned in changelog
          - Combined under a meta PR
          - Documentation-only or infra work
          - Outside computed date window
          - Title did not match any changelog line
        </analysis>
      </step>

      <step number="4">
        <action>Ask for inclusion policy</action>
        <tool>ask_followup_question</tool>
        <template><![CDATA[
<ask_followup_question>
<question>Changelog alignment for v[VERSION]: [IN_COUNT] PRs referenced, [EX_COUNT] not referenced. How should I proceed?</question>
<follow_up>
<suggest>Only include the PRs referenced in the changelog</suggest>
<suggest>Include all PRs from the date range</suggest>
<suggest>Review each excluded PR one by one so I can choose</suggest>
</follow_up>
</ask_followup_question>
        ]]></template>
        <critical>Do not proceed until one of the provided options is selected.</critical>
      </step>

      <step number="5" optional="true">
        <when>User selects per-PR review</when>
        <action>Iteratively review excluded PRs</action>
        <loop>
          For each PR in the excluded set:
          - Show title, author, brief labels, and a 1â€“2 sentence user-impact summary
          - Ask: include this PR?
          - Options: "Yes, include this PR" or "No, skip this PR"
          - Build the final inclusion set as (in_changelog âˆª user_selected_inclusions)
        </loop>
        <template><![CDATA[
<ask_followup_question>
<question>Include PR #[NUMBER] - [TITLE]? Short analysis: [WHY IT MATTERS].</question>
<follow_up>
<suggest>Yes, include this PR</suggest>
<suggest>No, skip this PR</suggest>
</follow_up>
</ask_followup_question>
        ]]></template>
        <completion>After the loop, proceed with the finalized PR set.</completion>
      </step>
      
      <handoff>Proceed to feature selection using the finalized PR set. Persist included/excluded lists to .roo/tmp/release-notes/temp_pr_inclusion.json for downstream filtering.</handoff>
    </phase>

    <phase name="compilation">
      <step number="1">
        <action>Read and organize PR findings (filtered to finalized inclusion set)</action>
        <inputs>
          <file>.roo/tmp/release-notes/temp_pr_analysis.md</file>
          <file optional="true">.roo/tmp/release-notes/temp_pr_inclusion.json</file>
        </inputs>
        <precondition>
          If .roo/tmp/release-notes/temp_pr_inclusion.json does not exist, you MUST execute the changelog_alignment phase now to obtain an inclusion decision, then retry this step.
        </precondition>
        <filtering>
          Include only PRs listed in "included" from .roo/tmp/release-notes/temp_pr_inclusion.json. Do not fall back to using all analyzed PRs without an explicit inclusion policy.
        </filtering>
        <categories>Features, QOL Improvements, Bug Fixes, Provider Updates</categories>
        <critical>QOL Improvements MUST come before Bug Fixes</critical>
      </step>
      
      <step number="2">
        <action>Confirm feature highlighting with user</action>
        <tool>ask_followup_question</tool>
        <template><![CDATA[
I've analyzed all PRs for v[VERSION]. Here are the changes I found:

**Major Features:**
[List major features with brief descriptions]

**Bug Fixes:** [COUNT] fixes
**QOL Improvements:** [COUNT] improvements
**Other Changes:** [COUNT] items

Which features should I highlight with expanded sections in the release notes?
        ]]></template>
        <gating>
          <rule>Do not proceed until an explicit selection from the provided options is received.</rule>
          <rule>On freeform responses, re-ask with reformulated options derived from the user's input until a provided option is chosen.</rule>
        </gating>
        <critical>Must get explicit confirmation before writing notes; see user_interactions.feature_selection.gating_rules</critical>
      </step>
      
      <step number="3">
        <action>Create release notes file</action>
        <format>
          For patch versions (X.Y.Z): docs/update-notes/vX.Y.Z.mdx
          For minor/major summaries (X.Y): docs/update-notes/vX.Y.mdx
        </format>
      </step>
      
      <step number="4">
        <action>For patch releases: Get user confirmation</action>
        <critical>
          Do NOT update combined notes until user confirms patch notes are final
        </critical>
      </step>
      
      <step number="5">
        <action>Update documentation indexes</action>
        <files>
          - index.md (chronological list)
          - sidebars.ts (navigation)
          - Combined notes for patch releases (ONLY after confirmation)
        </files>
      </step>
      
      <step number="6">
        <action>Create documentation update task</action>
        <when>If any documentation flags were identified</when>
        <tool>new_task with mode="documentation-writer"</tool>
      </step>
      <step number="7">
        <action>Cleanup temporary files</action>
        <details>Delete .roo/tmp/release-notes/* (temp_pr_analysis.md, temp_pr_list.md, temp_pr_inclusion.json) after notes are finalized.</details>
      </step>
    </phase>
  </main_workflow>

  <special_workflows>
    <workflow name="discord_only">
      <description>Generate Discord format from existing release files</description>
      <transformations>
        - Remove PR links and numbers
        - Convert /path to https://docs.roocode.com/path
        - Convert "* " list bullets to "â€¢ " bullets
        - Add footer link with markdown format
        - Handle compression if requested
        - Wrap entire output in markdown code block
      </transformations>
      <formatting_rules>
        <rule>Title format: # ðŸš€ Roo Code X.Y.Z Release Notes</rule>
        <rule>Include summary in intro sentence listing key features</rule>
        <rule>Use "Feature Highlights" instead of "Major Features"</rule>
        <rule>Never use the word "powerful"</rule>
        <rule>No version numbers in body text (only header/footer)</rule>
        <rule>No "Happy coding!" or similar closings</rule>
        <rule>Footer: ðŸ“š **Full Release Notes** [vX.Y.Z](link)</rule>
      </formatting_rules>
      <output>Formatted text wrapped in ```markdown code block (no files created)</output>
    </workflow>

    <workflow name="discord_combined">
      <description>Generate combined Discord format from multiple release files</description>
      <steps>
        <step>Read all specified release note files</step>
        <step>Merge and deduplicate features across versions</step>
        <step>Create unified summary sentence</step>
        <step>Apply Discord formatting rules</step>
      </steps>
      <formatting_rules>
        <rule>Title format: # ðŸš€ Roo Code X.Y.Z-X.Y.Z Release Updates</rule>
        <rule>Intro sentence summarizes all key features from all versions</rule>
        <rule>Combine similar sections across versions</rule>
        <rule>Footer with links to each version: [vX.Y.Z](link) | [vX.Y.Z](link)</rule>
        <rule>Wrap entire output in ```markdown code block</rule>
      </formatting_rules>
      <output>Combined formatted text (no files created)</output>
    </workflow>

    <workflow name="version_only">
      <description>Extract PR list when user provides just a version</description>
      <steps>
        <step>Ensure parent created .roo/tmp/release-notes/temp_pr_list.md (empty)</step>
        <step>Spawn PR extraction subtask using new_task with mode="release-notes-writer"</step>
        <step>Subtask appends PR list to .roo/tmp/release-notes/temp_pr_list.md using insert_content line 0</step>
        <step>Ask user how to proceed</step>
      </steps>
      <implementation>
        <tool>new_task</tool>
        <mode>release-notes-writer</mode>
        <message>Extract PR list for version [VERSION] and append to .roo/tmp/release-notes/temp_pr_list.md using insert_content line 0</message>
      </implementation>
    </workflow>

    <workflow name="latest">
      <description>Auto-detect missing versions</description>
      <steps>
        <step>Find most recent release notes</step>
        <step>List existing docs files in docs/update-notes (vX.Y or vX.Y.Z)</step>
        <step>List tags or releases from GitHub</step>
        <step>Compute missing versions (tags minus existing docs)</step>
        <step>Ask which to process</step>
      </steps>
      <commands>
        <existing_notes><![CDATA[
ls docs/update-notes | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?\.(md|mdx)$' | sed -E 's/\.(md|mdx)$//' | sort -V
        ]]></existing_notes>
        <tags><![CDATA[
gh api -X GET /repos/RooCodeInc/Roo-Code/tags --paginate --jq '.[].name' | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' | sort -V
        ]]></tags>
        <releases><![CDATA[
# Alternative:
gh release list --repo RooCodeInc/Roo-Code --limit 200 | awk '{print $1}' | grep -E '^v[0-9]+\.[0-9]+(\.[0-9]+)?$' | sort -V
        ]]></releases>
        <note>Present the set difference (tags/releases not present in docs) as candidates.</note>
      </commands>
      <handoff>After the user selects versions to process, immediately execute the changelog_alignment phase for each selected version before entering the compilation phase.</handoff>
    </workflow>
  </special_workflows>

  <critical_rules>
    <rule priority="CRITICAL">
      Date format is YYYY-MM-DD (ISO 8601) where MM is month (01-12)
    </rule>
    <rule priority="CRITICAL">
      Parent task creates temp files, subtasks only append
    </rule>
    <rule priority="HIGH">
      Always acknowledge PR author AND issue reporter
    </rule>
    <rule priority="HIGH">
      Focus on user benefits, not technical implementation
    </rule>
    <rule priority="HIGH">
      QOL Improvements section MUST come before Bug Fixes
    </rule>
  </critical_rules>
</workflow_instructions>